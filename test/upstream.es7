'use strict'

const test      = require('tap'),
      request   = require('supertest'),
      Ellipse   = require('..'),
      result    = [],
      errResult = []

let app  = new Ellipse,
    app2 = new Ellipse

function done(n) {
    return () => result.push(n)
}

// errors //

app.get('/error',
    async (ctx, next) => {
        await next()
        throw new Error('test')
    },
    ctx => ctx.send('ok')
)

app.get('/error2',
    (ctx, next) => {
        errResult.push(1)
        return next().catch(err => {
            errResult.push(4)
            ctx.res.status(500).send()
        })
    },
    (ctx, next) => {
        errResult.push(2)
        return next()
    },
    function () {
        errResult.push(3)
        throw new Error('test')
    }
)

app.param('test1', () => {
    throw new Error('test')
})

app.param('test2', (ctx, next) =>
    next(new Error('test')))

app.get('/error3/1/:test1', ctx => ctx.send())
app.get('/error3/2/:test2', ctx => ctx.send())

app.on('error', (err, ctx) => {
    test.pass('upstream error caught')
    ctx.status = 500
    ctx.send()
})

// control flow //

app.use((ctx, next) => {
    result.push(1)
    return next().then(done(26))
})

app.use((ctx, next) => {
    result.push(2)
    return next().then(done(25))
})

app.use(async (ctx, next) => {
    result.push(3)
    await next()
    result.push(24)
})

app.use(async (ctx, next) => {
    result.push(4)
    await next()
    result.push(23)
})

app.param('test', (ctx, next) => {
    result.push(5)
    return next().then(done(22))
})

app.get('/:test',
    (ctx, next) => {
        result.push(6)
        return next().then(done(21))
    },
    (ctx, next) => {
        result.push(7)
        return next().then(done(20))
    },
    async (ctx, next) => {
        result.push(8)
        await next()
        result.push(19)
    },
    async (ctx, next) => {
        result.push(9)
        await next()
        result.push(18)
    },
    (ctx, next) => {
        result.push(10)
        return next().then(done(17))
    },
    async (ctx, next) => {
        result.push(11)
        ctx.body = 'ok'
        await next()
        result.push(16)
    }
)

const sub = new Ellipse.Router
app.use(sub)

sub.use((ctx, next) => {
    result.push(12)
    return next().then(done(15))
})

sub.use(async (ctx, next) => {
    ctx.body = 'ok'
    result.push(13)
    await next()
    result.push(14)
    ctx.send()
})

// manipulating response upstream

app2.use((ctx, next) => {
    const time = new Date
    return next().then(() => {
        ctx.set('x-response-time', new Date - time)
    })
})

app2.get('/', ctx => {
    ctx.body = 'yeah!'
    ctx.send()
})

test.plan(9)
test.tearDown(() => {
    app.close()
    app2.close()
})

request(app = app.listen())
    .get('/test')
    .expect(200, err => {
        if (err)
            test.threw(err)
        else {
            const expected = [
                1,  2,  3,  4,
                5,  6,  7,  8,
                9,  10, 11, 12,
                13, 14, 15, 16,
                17, 18, 19, 20,
                21, 22, 23, 24,
                25, 26
            ]
            test.same(result, expected, 'control should flow as expected')
        }
    })

request(app)
    .get('/error')
    .expect(200, 'ok', err => {
        if (err)
            test.threw(err)
        else
            test.pass('response received')
    })

request(app)
    .get('/error2')
    .expect(500, err => {
        if (err)
            test.threw(err)
        else
            test.same(errResult, [ 1, 2, 3, 4 ], 'control should flow as expected (in case of error)')
    })

request(app)
    .get('/error3/1/t')
    .expect(500, err => {
        if (err)
            test.threw(err)
        else
            test.pass('error caught in param processor (threw)')
    })

request(app)
    .get('/error3/2/t')
    .expect(500, err => {
        if (err)
            test.threw(err)
        else
            test.pass('error caught in param processor (next)')
    })

request(app2 = app2.listen())
    .get('/')
    .expect(res => {
        if (!('x-powered-by' in res.headers) && !isNaN(res.headers[ 'x-powered-by' ]))
            throw new Error('x-powered-by header is expected, but missing')
    })
    .expect(200, 'yeah!', err => {
        if (err)
            test.threw(err)
        else
            test.pass('response should be manipulated upstream')
    })
